### 问题描述
---
[原题官网链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

---

**问题描述**
> 给一个有序数组nums，**原地删除重复出现**的元素，使每个元素**只出现一次** ，**返回删除后数组的新长度**;
>
> **不使用额外的数组空间**，你必须在**原地修改**输入数组，并在使用O(1)额外空间的条件下完成

---
**示例输出1**
> 输入：nums = [1,1,2]
>
> 输出：2, nums = [1,2]
>
> 解释：函数应该返回新的长度2，并且原数组nums的前两个元素被修改为1, 2。不需要考虑数组中超出新长度后面的元素

---
**示例输出2**
> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
>
> 输出：5, nums = [0,1,2,3,4]
>
> 解释：函数应该返回新的长度5，并且原数组nums的前五个元素被修改为0, 1, 2, 3, 4。不需要考虑数组中超出新长度后面的元素

---


### 题解思路
1. 数组是有序的，我们可以很简单地找到**最后一个重复的相同元素所在位置i**，下一个位置i+1就是下一个不同元素的位置，然后继续找重复的相同元素坐在位置，继续循环直到数组结尾;

2. 不使用额外数组空间，就需要我们在原地修改，所以在C++中一般使用引用；

3. 需要返回数组的新长度，直接使用一个count来计数并且作为数组递增的下标就行


### 代码实现
```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int ans = 0;
        int count = 0;

        for (int i = 0; i < nums.size();) {
            ans = nums[i];

            int j = i + 1;
            for (; j < nums.size(); ++j){
                if (nums[j] != ans)
                    break;
            }

            nums[count++] = ans;
            i = j;
        }

        return count;
    }
};
```
