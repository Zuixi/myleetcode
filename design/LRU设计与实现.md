### LRU

> LRU算法是一种缓存淘汰策略，计算机缓存有限，若缓存满则需要删除一些内容，给新内容腾出位置，如何删除没用的缓存呢？不同的判定策略对于**没用的定义是不一样的**

LRU缓存淘汰算法是一种常用策略，LRU的全称是`Least Recently Used`，即认为**最近使用的数据是最有用的，很久没用过的就是无用的**。


### LRU算法描述

![](https://myimages-wqz.oss-cn-shanghai.aliyuncs.com/intern/202209021431902.png)

* 接收一个参数`capacity`作为缓存的最大容量
* 实现两个`API`，一个`put(key,val)`方法存入键值对，另一个`get(key)`获取`key`对应的`val`，若`key`不存在则返回-1

**`get`和`put`都是`O(1)`的复杂度

**算法描述：**
```
/* 缓存容量为 2 */
LRUCache cache = new LRUCache(2);
// 你可以把 cache 理解成一个队列
// 假设左边是队头，右边是队尾
// 最近使用的排在队头，久未使用的排在队尾
// 圆括号表示键值对 (key, val)

cache.put(1, 1);
// cache = [(1, 1)]

cache.put(2, 2);
// cache = [(2, 2), (1, 1)]

cache.get(1);       // 返回 1
// cache = [(1, 1), (2, 2)]
// 解释：因为最近访问了键 1，所以提前至队头
// 返回键 1 对应的值 1

cache.put(3, 3);
// cache = [(3, 3), (1, 1)]
// 解释：缓存容量已满，需要删除内容空出位置
// 优先删除久未使用的数据，也就是队尾的数据
// 然后把新的数据插入队头

cache.get(2);       // 返回 -1 (未找到)
// cache = [(3, 3), (1, 1)]
// 解释：cache 中不存在键为 2 的数据

cache.put(1, 4);    
// cache = [(1, 4), (3, 3)]
// 解释：键 1 已存在，把原始值 1 覆盖为 4
// 不要忘了也要将键值对提前到队头
```

![](https://myimages-wqz.oss-cn-shanghai.aliyuncs.com/intern/202208191503510.png)
### LRU算法设计

要让`put`和`get`方法的时间复杂度为`O(1)`，我们可以总结出`cache`这个数据结构必要的条件：

1. 显然`cache`中的元素**必须有时序**，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。
2. 要在`cache`中快速找某个`key`是否已存在并得到对应的`val`；每次访问`cache`中的某个`key`，需要将这个元素变为最近使用的，也就是说`cache`**要支持在任意位置快速插入和删除元素**。

哈希表查找快，但是**数据无固定顺序**；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：**哈希链表**

![](https://myimages-wqz.oss-cn-shanghai.aliyuncs.com/intern/202209021555550.png)

哈希链表分析上面的条件：

1. 若每次从链表末尾添加元素，则**越靠近尾部的元素就是最近使用的，越靠近头部的就是不常用的**
2. 对于给定的`key`，可以通过hash表快速定位到链表节点取得`val`
3. 链表支持在任意位置插入和删除，但传统的链表无法按照索引快速访问某一个位置的元素，借助哈希表就可实现

![](https://myimages-wqz.oss-cn-shanghai.aliyuncs.com/intern/202208191503510.png)
### 代码实现

[**LRU C++代码实现**](../src/c%2B%2B/include/lrc.h)